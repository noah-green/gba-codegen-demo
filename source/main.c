#include <tonc.h>

// This file is autogenerated from the file in the graphics folder
#include "walkcycle.h"
#include "walkcycle_animation.h"

OBJ_ATTR obj_buffer[128];

OBJ_ATTR* load_sprite(void)
{
	// Load tiles and palette of sprite into video and palete RAM. Note that
	// regular memcpy() won't work. To write to VRAM, it is required to write in
	// units of 16 or 32 bytes. memcpy() doesn't guarantee the size of the
	// writes, but mempcy32() always writes in chunks of 32 bytes.
	memcpy32(&tile_mem[4][0], walkcycleTiles, walkcycleTilesLen / 4);
	memcpy32(pal_obj_mem, walkcyclePal, walkcyclePalLen / 4);

	oam_init(obj_buffer, 128);

	OBJ_ATTR *walkcycle = &obj_buffer[0];

	obj_set_attr(walkcycle, ATTR0_TALL, ATTR1_SIZE_32, ATTR2_PALBANK(0) | 0);
	// Set position
	obj_set_pos(walkcycle, 112, 64);

	oam_copy(oam_mem, obj_buffer, 1); // Update first OAM object

	return walkcycle;
}

int main(void)
{
	irq_init(NULL);
	irq_enable(II_VBLANK);
	OBJ_ATTR *sprite = load_sprite();

	WalkcycleAnimationState state;
	init_walkcycle_animation(&state, sprite, 0);
	start_walkFront(&state);

	sprite->attr2 = ATTR2_PALBANK(0) | 64;

	REG_DISPCNT = DCNT_MODE0 | DCNT_BG0 | DCNT_OBJ | DCNT_OBJ_1D;

	while (1) {
		vid_vsync();
		key_poll();

		if (key_hit(KEY_UP)) {
			start_walkBack(&state);
		}
		if (key_hit(KEY_DOWN)) {
			start_walkFront(&state);
		}
		if (key_hit(KEY_LEFT)) {
			start_walkLeft(&state);
		}
		if (key_hit(KEY_RIGHT)) {
			start_walkRight(&state);
		}
	
		update_walkcycle_animation(&state);
		oam_copy(oam_mem, obj_buffer, 1); 
	}
}
